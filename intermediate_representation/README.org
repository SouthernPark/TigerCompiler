#+TITLE Semantic Analysis
#+DATE <2023-02-13 Mon 15:21>
#+TODO: TODO INPROCESS UNSURE DONE

FRAME + Intermediate representation

* TODO Imporant Imporant Imporant
remove the following in signature of translate.sml
#+BEGIN_SRC
datatype exp = Ex of T.exp
              |Nx of T.stm
              |Cx of Temp.label * Temp.label -> T.stm
              |TODO
#+END_SRC

and place with:
#+BEGIN_SRC
type exp
#+END_SRC

also, in the structure remove /TODO/

The reason I do this, is to pass compiler error when other trans func is not finished


* check_list
| name         | translated | tested |
| NilExp       | yes        |        |
| IntExp       | yes        |        |
| PlusOp       | yes        |        |
| MinusOp      | yes        |        |
| TimesOp      | yes        |        |
| DivideOp     | yes        |        |
| EqOp         | yes        |        |
| NeqOp        | yes        |        |
| LtOp         | yes        |        |
| LeOp         | yes        |        |
| GtOp         | yes        |        |
| GeOp         | yes        |        |
| BreakExp     | yes        |        |
| RecordExp    | yes        |        |
| WhileExp     | no         |        |
| ForExp       | no         |        |
| ArrayExp     | yes        |        |
| SimpleVar    | no         |        |
| FieldVar     | no         |        |
| SubscriptVar | no         |        |
| VarExp       | no         |        |
| StringExp    | yes        |        |
| CallExp      | no         |        |
| SeqExp       | no         |        |
| AssignExp    | yes        |        |
| IfExp        | yes        |        |
| TypeDec      | no         |        |
| NameTy       | no         |        |
| RecordTy     | no         |        |
| ArrayTy      | no         |        |
| base type    | no         |        |
| base func    | no         |        |



* Grader to read

+ we currently set all variables as escaping
+ we changed the breakexp type to BOTTOM/IMPOSSIBILITY (in semant.sml) to keep consistent with our type system
+ we change the exit type to BOTTOM/IMPOSSIBILITY (in env.sml) to keep consistent  with type system
+ if the compiler can not find func name in CallExp, then we will raise error. (/raise ErrorMsg.Error/)
+ how we handle error cases in func call:
  - if the caller does not provide enough args to callee, then we use as many as possible
  - if the caller provide too many args, we just use the first k args, where k is equal to arg length of callee
  - if the callee func name does not exist, then we raise an ErrorMsg.Error
  - if there are type error in args, we pass as all correct args before the error args
+ how we handle break error:
  - if the break lead to an error, we will pass a arbitrary loop end Label to transBreak func
+ how we handle exp when there's error in type checking:
  - For those having error type checking, we will return ERROREXP for exp. It's defined in translate.sml, which is a int 0 exp.

* Requirements

** chapter 6 FRAME

+ implement the mips frame module (in mipsframe.sml) following the signature in frame.sig
  - Frame can create new frame to hold function arguments
  - Frame can create space for local variables
  - Frame can give back function args

+ implement Translate module (in translate.sml) following the signature in translate.sml
  - Translate module can create new frame by using functions in Frame
  - Translate module can give back function args by using functins in Frame
  - Translate module maintain nested funciton level

+ Augment semant module
  - to allocate locations for local variables by using functions in Translate module (deal with fundec, vardec)
  - to keep track of nesting levels (deal with function call)

*** relations between frame, translate, and semant module

#+BEGIN_SRC

     +-------------------+
     |   semant          |
     +-------------------+
        |
        v
     +-------------------+
     |   translate       |
     +--+----------------+
        |
        v
 +----------+    +---------+
 |  Frame   |--->|  Temp   |
 +----------+    +---------+

#+END_SRC

Semant can not call Frame directly to alloc frame, it calls translate to do that.



* update on var environment

The current var entry in semantic analysis (previous chapter) is defined as:
#+BEGIN_SRC
datatype enventry = VarEntry of {ty: ty}
                  | FunEntry of {formals: ty list, result: ty}
#+END_SRC

The above definition is enough for var type checking and function type checking. But not enough for later Intermediate Translation. The var environment need to tell semant how to find the variable in the funciton frame and where to find the function. Thus we get the following definition:

#+BEGIN_SRC
datatype enventry = VarEntry of {access: Translate.access, ty: ty}
                  | FunEntry of {level:Translate.level, label:Temp.label, formals: ty list, result: ty}
#+END_SRC

access in VarEntry is used to find a variable in a function frame.

level in FunEntry info about function nesting level (we use parent level, like linked list to handle that) and also function frame. Label is where we can access the function machine code in memory.

* FRAME
#+BEGIN_SRC

	 +--------------+
	 |              |
	 |              |
	 +--------------+
	 | arg 2        |
	 +--------------+
	 | arg 1        |
	 +--------------+
FP --->	 | static link  |
	 +--------------+
	 |              |
	 | local var    |
	 |              |
	 +--------------+
#+END_SRC

Incoming arguments is InFrame(x) where x > 0, while local var is InFrame(x) where x < 0

All elements in the frame should be word size (4 bytes), which is required by Tiger.

Record and array element is just passing by pointers (word size).

The content of array and record is just in the heap.






















* static link
Static link is used by nested functions to fetch functions outside. Static link is passed when a function calls another function.

we use unit ref to compare level (note, unit ref can only compared with =, in other words, we can only compare with equality rather than inequality).


** passing static link in function call
assume function f calls function g, there are three cases:
+ f is on the same level of g (we call g and f siblings), then f needs to pass its static link fetches from f's frame to g;
  - this usually happens when recurse or mutual recurse
+ f has a higher level than g (g is defined as a nested func inside f), then f needs to pass its frame pointer to g
  - It seems that f can only calls g that is one level below, cause for functions that are nested inside of g, f can not see it
  - If f has a higher level than g, then g is defined in the let exp, f can only calls g in the body of let exp.
+ f has a lower level than g (this usually happens when nested function call outer functions), then we have to recusively find the parent frame of f until we reach the same level with g and use that static link.

** fetch stack link from variable

We need to need which frame we need to use to fetch the varablie. Variable also has a level.

+ If the variable is in the same level, then we use the current frame pointer.
+ If the variable's level is a parent level of function level, then we use the static link.
+ Otherwise, we recursively find the fucntion whose parent level is the same as the variable's level.



* TODO

** TODO Later view shift

See also pages 168 and 261 for more discussion of the view shift






** TODO Later Caculating escapes

Currently, we regarding every variables/arguments as escaping. Later on, we will implement what is described in page 138.

** TODO fun name and var name have the same name (need to check)
** TODO fun name and var name have the same name (need to check)


